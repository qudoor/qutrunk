#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:package_prefix=qutrunk.thrift.
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import qutrunk.thrift.code.ttypes

from thrift.transport import TTransport
all_structs = []


class ExecCmdType(object):
    ExecTypeDefault = 0
    ExecTypeCpuSingle = 1
    ExecTypeCpuMpi = 2
    ExecTypeGpuSingle = 3

    _VALUES_TO_NAMES = {
        0: "ExecTypeDefault",
        1: "ExecTypeCpuSingle",
        2: "ExecTypeCpuMpi",
        3: "ExecTypeGpuSingle",
    }

    _NAMES_TO_VALUES = {
        "ExecTypeDefault": 0,
        "ExecTypeCpuSingle": 1,
        "ExecTypeCpuMpi": 2,
        "ExecTypeGpuSingle": 3,
    }


class PauliOperType(object):
    POT_PAULI_I = 0
    POT_PAULI_X = 1
    POT_PAULI_Y = 2
    POT_PAULI_Z = 3

    _VALUES_TO_NAMES = {
        0: "POT_PAULI_I",
        1: "POT_PAULI_X",
        2: "POT_PAULI_Y",
        3: "POT_PAULI_Z",
    }

    _NAMES_TO_VALUES = {
        "POT_PAULI_I": 0,
        "POT_PAULI_X": 1,
        "POT_PAULI_Y": 2,
        "POT_PAULI_Z": 3,
    }


class RandomCardStateType(object):
    RANDOM_MC_S0 = 0
    RANDOM_MC_S1 = 1
    RANDOM_EEPROM_S = 2
    RANDOM_PAR_VALUE_S = 3
    RANDOM_EEPROM_CHECK_S = 4
    RANDOM_EEPROM_RW_S = 5
    RANDOM_LD_TEMP_S = 6
    RANDOM_BD_TEMP_S = 7
    RANDOM_LINK_S = 8

    _VALUES_TO_NAMES = {
        0: "RANDOM_MC_S0",
        1: "RANDOM_MC_S1",
        2: "RANDOM_EEPROM_S",
        3: "RANDOM_PAR_VALUE_S",
        4: "RANDOM_EEPROM_CHECK_S",
        5: "RANDOM_EEPROM_RW_S",
        6: "RANDOM_LD_TEMP_S",
        7: "RANDOM_BD_TEMP_S",
        8: "RANDOM_LINK_S",
    }

    _NAMES_TO_VALUES = {
        "RANDOM_MC_S0": 0,
        "RANDOM_MC_S1": 1,
        "RANDOM_EEPROM_S": 2,
        "RANDOM_PAR_VALUE_S": 3,
        "RANDOM_EEPROM_CHECK_S": 4,
        "RANDOM_EEPROM_RW_S": 5,
        "RANDOM_LD_TEMP_S": 6,
        "RANDOM_BD_TEMP_S": 7,
        "RANDOM_LINK_S": 8,
    }


class Amplitude(object):
    """
    Attributes:
     - reals
     - imags
     - startind
     - numamps

    """


    def __init__(self, reals=None, imags=None, startind=None, numamps=None,):
        self.reals = reals
        self.imags = imags
        self.startind = startind
        self.numamps = numamps

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.reals = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readDouble()
                        self.reals.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.imags = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readDouble()
                        self.imags.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.startind = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.numamps = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Amplitude')
        if self.reals is not None:
            oprot.writeFieldBegin('reals', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.reals))
            for iter12 in self.reals:
                oprot.writeDouble(iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.imags is not None:
            oprot.writeFieldBegin('imags', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.imags))
            for iter13 in self.imags:
                oprot.writeDouble(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startind is not None:
            oprot.writeFieldBegin('startind', TType.I32, 3)
            oprot.writeI32(self.startind)
            oprot.writeFieldEnd()
        if self.numamps is not None:
            oprot.writeFieldBegin('numamps', TType.I32, 4)
            oprot.writeI32(self.numamps)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.reals is None:
            raise TProtocolException(message='Required field reals is unset!')
        if self.imags is None:
            raise TProtocolException(message='Required field imags is unset!')
        if self.startind is None:
            raise TProtocolException(message='Required field startind is unset!')
        if self.numamps is None:
            raise TProtocolException(message='Required field numamps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Matrix(object):
    """
    Attributes:
     - reals
     - imags
     - unitary

    """


    def __init__(self, reals=None, imags=None, unitary=None,):
        self.reals = reals
        self.imags = imags
        self.unitary = unitary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.reals = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = []
                        (_etype23, _size20) = iprot.readListBegin()
                        for _i24 in range(_size20):
                            _elem25 = iprot.readDouble()
                            _elem19.append(_elem25)
                        iprot.readListEnd()
                        self.reals.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.imags = []
                    (_etype29, _size26) = iprot.readListBegin()
                    for _i30 in range(_size26):
                        _elem31 = []
                        (_etype35, _size32) = iprot.readListBegin()
                        for _i36 in range(_size32):
                            _elem37 = iprot.readDouble()
                            _elem31.append(_elem37)
                        iprot.readListEnd()
                        self.imags.append(_elem31)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.unitary = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Matrix')
        if self.reals is not None:
            oprot.writeFieldBegin('reals', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.reals))
            for iter38 in self.reals:
                oprot.writeListBegin(TType.DOUBLE, len(iter38))
                for iter39 in iter38:
                    oprot.writeDouble(iter39)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.imags is not None:
            oprot.writeFieldBegin('imags', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.imags))
            for iter40 in self.imags:
                oprot.writeListBegin(TType.DOUBLE, len(iter40))
                for iter41 in iter40:
                    oprot.writeDouble(iter41)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.unitary is not None:
            oprot.writeFieldBegin('unitary', TType.BOOL, 3)
            oprot.writeBool(self.unitary)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.reals is None:
            raise TProtocolException(message='Required field reals is unset!')
        if self.imags is None:
            raise TProtocolException(message='Required field imags is unset!')
        if self.unitary is None:
            raise TProtocolException(message='Required field unitary is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Cmdex(object):
    """
    Attributes:
     - amp
     - mat

    """


    def __init__(self, amp=None, mat=None,):
        self.amp = amp
        self.mat = mat

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.amp = Amplitude()
                    self.amp.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.mat = Matrix()
                    self.mat.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Cmdex')
        if self.amp is not None:
            oprot.writeFieldBegin('amp', TType.STRUCT, 1)
            self.amp.write(oprot)
            oprot.writeFieldEnd()
        if self.mat is not None:
            oprot.writeFieldBegin('mat', TType.STRUCT, 2)
            self.mat.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MeasureCond(object):
    """
    Attributes:
     - enable
     - idx
     - cond_value

    """


    def __init__(self, enable=None, idx=None, cond_value=None,):
        self.enable = enable
        self.idx = idx
        self.cond_value = cond_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.cond_value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MeasureCond')
        if self.enable is not None:
            oprot.writeFieldBegin('enable', TType.BOOL, 1)
            oprot.writeBool(self.enable)
            oprot.writeFieldEnd()
        if self.idx is not None:
            oprot.writeFieldBegin('idx', TType.I32, 2)
            oprot.writeI32(self.idx)
            oprot.writeFieldEnd()
        if self.cond_value is not None:
            oprot.writeFieldBegin('cond_value', TType.I32, 3)
            oprot.writeI32(self.cond_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.enable is None:
            raise TProtocolException(message='Required field enable is unset!')
        if self.idx is None:
            raise TProtocolException(message='Required field idx is unset!')
        if self.cond_value is None:
            raise TProtocolException(message='Required field cond_value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Cmd(object):
    """
    Attributes:
     - gate
     - targets
     - controls
     - rotation
     - desc
     - inverse
     - cmdex
     - cond

    """


    def __init__(self, gate=None, targets=None, controls=None, rotation=None, desc=None, inverse=None, cmdex=None, cond=None,):
        self.gate = gate
        self.targets = targets
        self.controls = controls
        self.rotation = rotation
        self.desc = desc
        self.inverse = inverse
        self.cmdex = cmdex
        self.cond = cond

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.gate = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.targets = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readI32()
                        self.targets.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.controls = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = iprot.readI32()
                        self.controls.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.rotation = []
                    (_etype57, _size54) = iprot.readListBegin()
                    for _i58 in range(_size54):
                        _elem59 = iprot.readDouble()
                        self.rotation.append(_elem59)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.desc = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.inverse = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.cmdex = Cmdex()
                    self.cmdex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.cond = MeasureCond()
                    self.cond.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Cmd')
        if self.gate is not None:
            oprot.writeFieldBegin('gate', TType.STRING, 1)
            oprot.writeString(self.gate.encode('utf-8') if sys.version_info[0] == 2 else self.gate)
            oprot.writeFieldEnd()
        if self.targets is not None:
            oprot.writeFieldBegin('targets', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.targets))
            for iter60 in self.targets:
                oprot.writeI32(iter60)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.controls is not None:
            oprot.writeFieldBegin('controls', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.controls))
            for iter61 in self.controls:
                oprot.writeI32(iter61)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rotation is not None:
            oprot.writeFieldBegin('rotation', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.rotation))
            for iter62 in self.rotation:
                oprot.writeDouble(iter62)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.desc is not None:
            oprot.writeFieldBegin('desc', TType.STRING, 5)
            oprot.writeString(self.desc.encode('utf-8') if sys.version_info[0] == 2 else self.desc)
            oprot.writeFieldEnd()
        if self.inverse is not None:
            oprot.writeFieldBegin('inverse', TType.BOOL, 6)
            oprot.writeBool(self.inverse)
            oprot.writeFieldEnd()
        if self.cmdex is not None:
            oprot.writeFieldBegin('cmdex', TType.STRUCT, 7)
            self.cmdex.write(oprot)
            oprot.writeFieldEnd()
        if self.cond is not None:
            oprot.writeFieldBegin('cond', TType.STRUCT, 8)
            self.cond.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.gate is None:
            raise TProtocolException(message='Required field gate is unset!')
        if self.targets is None:
            raise TProtocolException(message='Required field targets is unset!')
        if self.controls is None:
            raise TProtocolException(message='Required field controls is unset!')
        if self.rotation is None:
            raise TProtocolException(message='Required field rotation is unset!')
        if self.desc is None:
            raise TProtocolException(message='Required field desc is unset!')
        if self.inverse is None:
            raise TProtocolException(message='Required field inverse is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Circuit(object):
    """
    Attributes:
     - cmds

    """


    def __init__(self, cmds=None,):
        self.cmds = cmds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.cmds = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = Cmd()
                        _elem68.read(iprot)
                        self.cmds.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Circuit')
        if self.cmds is not None:
            oprot.writeFieldBegin('cmds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.cmds))
            for iter69 in self.cmds:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cmds is None:
            raise TProtocolException(message='Required field cmds is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MeasureQubit(object):
    """
    Attributes:
     - idx
     - value

    """


    def __init__(self, idx=None, value=None,):
        self.idx = idx
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MeasureQubit')
        if self.idx is not None:
            oprot.writeFieldBegin('idx', TType.I32, 1)
            oprot.writeI32(self.idx)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.idx is None:
            raise TProtocolException(message='Required field idx is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MeasureQubits(object):
    """
    Attributes:
     - measure

    """


    def __init__(self, measure=None,):
        self.measure = measure

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.measure = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = MeasureQubit()
                        _elem75.read(iprot)
                        self.measure.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MeasureQubits')
        if self.measure is not None:
            oprot.writeFieldBegin('measure', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.measure))
            for iter76 in self.measure:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.measure is None:
            raise TProtocolException(message='Required field measure is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MeasureResult(object):
    """
    Attributes:
     - measures

    """


    def __init__(self, measures=None,):
        self.measures = measures

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.measures = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = MeasureQubits()
                        _elem82.read(iprot)
                        self.measures.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MeasureResult')
        if self.measures is not None:
            oprot.writeFieldBegin('measures', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.measures))
            for iter83 in self.measures:
                iter83.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.measures is None:
            raise TProtocolException(message='Required field measures is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InitQubitsReq(object):
    """
    Attributes:
     - id
     - qubits
     - density
     - exec_type
     - hosts

    """


    def __init__(self, id=None, qubits=None, density=None, exec_type=None, hosts=None,):
        self.id = id
        self.qubits = qubits
        self.density = density
        self.exec_type = exec_type
        self.hosts = hosts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.qubits = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.density = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.exec_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.hosts = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.hosts.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InitQubitsReq')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.qubits is not None:
            oprot.writeFieldBegin('qubits', TType.I32, 2)
            oprot.writeI32(self.qubits)
            oprot.writeFieldEnd()
        if self.density is not None:
            oprot.writeFieldBegin('density', TType.BOOL, 3)
            oprot.writeBool(self.density)
            oprot.writeFieldEnd()
        if self.exec_type is not None:
            oprot.writeFieldBegin('exec_type', TType.I32, 4)
            oprot.writeI32(self.exec_type)
            oprot.writeFieldEnd()
        if self.hosts is not None:
            oprot.writeFieldBegin('hosts', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.hosts))
            for iter90 in self.hosts:
                oprot.writeString(iter90.encode('utf-8') if sys.version_info[0] == 2 else iter90)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.qubits is None:
            raise TProtocolException(message='Required field qubits is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InitQubitsResp(object):
    """
    Attributes:
     - base

    """


    def __init__(self, base=None,):
        self.base = base

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = qutrunk.thrift.code.ttypes.BaseCode()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InitQubitsResp')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SendCircuitCmdReq(object):
    """
    Attributes:
     - id
     - circuit
     - final

    """


    def __init__(self, id=None, circuit=None, final=None,):
        self.id = id
        self.circuit = circuit
        self.final = final

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.circuit = Circuit()
                    self.circuit.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.final = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SendCircuitCmdReq')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.circuit is not None:
            oprot.writeFieldBegin('circuit', TType.STRUCT, 2)
            self.circuit.write(oprot)
            oprot.writeFieldEnd()
        if self.final is not None:
            oprot.writeFieldBegin('final', TType.BOOL, 3)
            oprot.writeBool(self.final)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SendCircuitCmdResp(object):
    """
    Attributes:
     - base

    """


    def __init__(self, base=None,):
        self.base = base

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = qutrunk.thrift.code.ttypes.BaseCode()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SendCircuitCmdResp')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CancelCmdReq(object):
    """
    Attributes:
     - id

    """


    def __init__(self, id=None,):
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CancelCmdReq')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CancelCmdResp(object):
    """
    Attributes:
     - base

    """


    def __init__(self, base=None,):
        self.base = base

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = qutrunk.thrift.code.ttypes.BaseCode()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CancelCmdResp')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetProbAmpReq(object):
    """
    Attributes:
     - id
     - index

    """


    def __init__(self, id=None, index=None,):
        self.id = id
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.index = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetProbAmpReq')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I64, 2)
            oprot.writeI64(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetProbAmpResp(object):
    """
    Attributes:
     - base
     - amp

    """


    def __init__(self, base=None, amp=None,):
        self.base = base
        self.amp = amp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = qutrunk.thrift.code.ttypes.BaseCode()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.amp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetProbAmpResp')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        if self.amp is not None:
            oprot.writeFieldBegin('amp', TType.DOUBLE, 2)
            oprot.writeDouble(self.amp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetProbOfAllOutcomReq(object):
    """
    Attributes:
     - id
     - targets

    """


    def __init__(self, id=None, targets=None,):
        self.id = id
        self.targets = targets

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.targets = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = iprot.readI32()
                        self.targets.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetProbOfAllOutcomReq')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.targets is not None:
            oprot.writeFieldBegin('targets', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.targets))
            for iter97 in self.targets:
                oprot.writeI32(iter97)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.targets is None:
            raise TProtocolException(message='Required field targets is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetProbOfAllOutcomResp(object):
    """
    Attributes:
     - base
     - pro_outcomes

    """


    def __init__(self, base=None, pro_outcomes=None,):
        self.base = base
        self.pro_outcomes = pro_outcomes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = qutrunk.thrift.code.ttypes.BaseCode()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.pro_outcomes = []
                    (_etype101, _size98) = iprot.readListBegin()
                    for _i102 in range(_size98):
                        _elem103 = iprot.readDouble()
                        self.pro_outcomes.append(_elem103)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetProbOfAllOutcomResp')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        if self.pro_outcomes is not None:
            oprot.writeFieldBegin('pro_outcomes', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.pro_outcomes))
            for iter104 in self.pro_outcomes:
                oprot.writeDouble(iter104)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAllStateReq(object):
    """
    Attributes:
     - id

    """


    def __init__(self, id=None,):
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAllStateReq')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAllStateResp(object):
    """
    Attributes:
     - base
     - all_state

    """


    def __init__(self, base=None, all_state=None,):
        self.base = base
        self.all_state = all_state

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = qutrunk.thrift.code.ttypes.BaseCode()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.all_state = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.all_state.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAllStateResp')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        if self.all_state is not None:
            oprot.writeFieldBegin('all_state', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.all_state))
            for iter111 in self.all_state:
                oprot.writeString(iter111.encode('utf-8') if sys.version_info[0] == 2 else iter111)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RunCircuitReq(object):
    """
    Attributes:
     - id
     - shots
     - free

    """


    def __init__(self, id=None, shots=None, free=None,):
        self.id = id
        self.shots = shots
        self.free = free

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.shots = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.free = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RunCircuitReq')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.shots is not None:
            oprot.writeFieldBegin('shots', TType.I32, 2)
            oprot.writeI32(self.shots)
            oprot.writeFieldEnd()
        if self.free is not None:
            oprot.writeFieldBegin('free', TType.I32, 3)
            oprot.writeI32(self.free)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.shots is None:
            raise TProtocolException(message='Required field shots is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RunCircuitResp(object):
    """
    Attributes:
     - base
     - result

    """


    def __init__(self, base=None, result=None,):
        self.base = base
        self.result = result

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = qutrunk.thrift.code.ttypes.BaseCode()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.result = MeasureResult()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RunCircuitResp')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.STRUCT, 2)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetExpecPauliProdReq(object):
    """
    Attributes:
     - id
     - pauli_prod

    """


    def __init__(self, id=None, pauli_prod=None,):
        self.id = id
        self.pauli_prod = pauli_prod

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.pauli_prod = []
                    (_etype115, _size112) = iprot.readListBegin()
                    for _i116 in range(_size112):
                        _elem117 = PauliProdInfo()
                        _elem117.read(iprot)
                        self.pauli_prod.append(_elem117)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetExpecPauliProdReq')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.pauli_prod is not None:
            oprot.writeFieldBegin('pauli_prod', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.pauli_prod))
            for iter118 in self.pauli_prod:
                iter118.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.pauli_prod is None:
            raise TProtocolException(message='Required field pauli_prod is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetExpecPauliProdResp(object):
    """
    Attributes:
     - base
     - expect

    """


    def __init__(self, base=None, expect=None,):
        self.base = base
        self.expect = expect

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = qutrunk.thrift.code.ttypes.BaseCode()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.expect = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetExpecPauliProdResp')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        if self.expect is not None:
            oprot.writeFieldBegin('expect', TType.DOUBLE, 2)
            oprot.writeDouble(self.expect)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PauliProdInfo(object):
    """
    Attributes:
     - oper_type
     - target

    """


    def __init__(self, oper_type=None, target=None,):
        self.oper_type = oper_type
        self.target = target

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.oper_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.target = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PauliProdInfo')
        if self.oper_type is not None:
            oprot.writeFieldBegin('oper_type', TType.I32, 1)
            oprot.writeI32(self.oper_type)
            oprot.writeFieldEnd()
        if self.target is not None:
            oprot.writeFieldBegin('target', TType.I32, 2)
            oprot.writeI32(self.target)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.oper_type is None:
            raise TProtocolException(message='Required field oper_type is unset!')
        if self.target is None:
            raise TProtocolException(message='Required field target is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetExpecPauliSumReq(object):
    """
    Attributes:
     - id
     - oper_type_list
     - term_coeff_list

    """


    def __init__(self, id=None, oper_type_list=None, term_coeff_list=None,):
        self.id = id
        self.oper_type_list = oper_type_list
        self.term_coeff_list = term_coeff_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.oper_type_list = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = iprot.readI32()
                        self.oper_type_list.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.term_coeff_list = []
                    (_etype128, _size125) = iprot.readListBegin()
                    for _i129 in range(_size125):
                        _elem130 = iprot.readDouble()
                        self.term_coeff_list.append(_elem130)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetExpecPauliSumReq')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.oper_type_list is not None:
            oprot.writeFieldBegin('oper_type_list', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.oper_type_list))
            for iter131 in self.oper_type_list:
                oprot.writeI32(iter131)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.term_coeff_list is not None:
            oprot.writeFieldBegin('term_coeff_list', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.term_coeff_list))
            for iter132 in self.term_coeff_list:
                oprot.writeDouble(iter132)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.oper_type_list is None:
            raise TProtocolException(message='Required field oper_type_list is unset!')
        if self.term_coeff_list is None:
            raise TProtocolException(message='Required field term_coeff_list is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetExpecPauliSumResp(object):
    """
    Attributes:
     - base
     - expect

    """


    def __init__(self, base=None, expect=None,):
        self.base = base
        self.expect = expect

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = qutrunk.thrift.code.ttypes.BaseCode()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.expect = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetExpecPauliSumResp')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        if self.expect is not None:
            oprot.writeFieldBegin('expect', TType.DOUBLE, 2)
            oprot.writeDouble(self.expect)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetRandomCardInfoReq(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetRandomCardInfoReq')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetRandomCardInfoResp(object):
    """
    Attributes:
     - base
     - count
     - driver_version
     - library_version
     - cards

    """


    def __init__(self, base=None, count=None, driver_version=None, library_version=None, cards=None,):
        self.base = base
        self.count = count
        self.driver_version = driver_version
        self.library_version = library_version
        self.cards = cards

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = qutrunk.thrift.code.ttypes.BaseCode()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.driver_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.library_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.cards = []
                    (_etype136, _size133) = iprot.readListBegin()
                    for _i137 in range(_size133):
                        _elem138 = RandomCardInfo()
                        _elem138.read(iprot)
                        self.cards.append(_elem138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetRandomCardInfoResp')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 2)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.driver_version is not None:
            oprot.writeFieldBegin('driver_version', TType.I32, 3)
            oprot.writeI32(self.driver_version)
            oprot.writeFieldEnd()
        if self.library_version is not None:
            oprot.writeFieldBegin('library_version', TType.I32, 4)
            oprot.writeI32(self.library_version)
            oprot.writeFieldEnd()
        if self.cards is not None:
            oprot.writeFieldBegin('cards', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.cards))
            for iter139 in self.cards:
                iter139.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        if self.count is None:
            raise TProtocolException(message='Required field count is unset!')
        if self.driver_version is None:
            raise TProtocolException(message='Required field driver_version is unset!')
        if self.library_version is None:
            raise TProtocolException(message='Required field library_version is unset!')
        if self.cards is None:
            raise TProtocolException(message='Required field cards is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RandomCardInfo(object):
    """
    Attributes:
     - device_index
     - mode
     - ld_temp
     - bd_temp
     - states

    """


    def __init__(self, device_index=None, mode=None, ld_temp=None, bd_temp=None, states=None,):
        self.device_index = device_index
        self.mode = mode
        self.ld_temp = ld_temp
        self.bd_temp = bd_temp
        self.states = states

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.device_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.ld_temp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.bd_temp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.states = {}
                    (_ktype141, _vtype142, _size140) = iprot.readMapBegin()
                    for _i144 in range(_size140):
                        _key145 = iprot.readI32()
                        _val146 = iprot.readI32()
                        self.states[_key145] = _val146
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RandomCardInfo')
        if self.device_index is not None:
            oprot.writeFieldBegin('device_index', TType.I32, 1)
            oprot.writeI32(self.device_index)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 2)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.ld_temp is not None:
            oprot.writeFieldBegin('ld_temp', TType.DOUBLE, 3)
            oprot.writeDouble(self.ld_temp)
            oprot.writeFieldEnd()
        if self.bd_temp is not None:
            oprot.writeFieldBegin('bd_temp', TType.DOUBLE, 4)
            oprot.writeDouble(self.bd_temp)
            oprot.writeFieldEnd()
        if self.states is not None:
            oprot.writeFieldBegin('states', TType.MAP, 5)
            oprot.writeMapBegin(TType.I32, TType.I32, len(self.states))
            for kiter147, viter148 in self.states.items():
                oprot.writeI32(kiter147)
                oprot.writeI32(viter148)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.device_index is None:
            raise TProtocolException(message='Required field device_index is unset!')
        if self.mode is None:
            raise TProtocolException(message='Required field mode is unset!')
        if self.ld_temp is None:
            raise TProtocolException(message='Required field ld_temp is unset!')
        if self.bd_temp is None:
            raise TProtocolException(message='Required field bd_temp is unset!')
        if self.states is None:
            raise TProtocolException(message='Required field states is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SetRandomCardReq(object):
    """
    Attributes:
     - device_index
     - mode
     - reset

    """


    def __init__(self, device_index=None, mode=None, reset=None,):
        self.device_index = device_index
        self.mode = mode
        self.reset = reset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.device_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.reset = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetRandomCardReq')
        if self.device_index is not None:
            oprot.writeFieldBegin('device_index', TType.I32, 1)
            oprot.writeI32(self.device_index)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 2)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.reset is not None:
            oprot.writeFieldBegin('reset', TType.BOOL, 3)
            oprot.writeBool(self.reset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.device_index is None:
            raise TProtocolException(message='Required field device_index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SetRandomCardResp(object):
    """
    Attributes:
     - base

    """


    def __init__(self, base=None,):
        self.base = base

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = qutrunk.thrift.code.ttypes.BaseCode()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetRandomCardResp')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetRandomReq(object):
    """
    Attributes:
     - random_length
     - random_num
     - device_index

    """


    def __init__(self, random_length=None, random_num=None, device_index=None,):
        self.random_length = random_length
        self.random_num = random_num
        self.device_index = device_index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.random_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.random_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.device_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetRandomReq')
        if self.random_length is not None:
            oprot.writeFieldBegin('random_length', TType.I32, 1)
            oprot.writeI32(self.random_length)
            oprot.writeFieldEnd()
        if self.random_num is not None:
            oprot.writeFieldBegin('random_num', TType.I32, 2)
            oprot.writeI32(self.random_num)
            oprot.writeFieldEnd()
        if self.device_index is not None:
            oprot.writeFieldBegin('device_index', TType.I32, 3)
            oprot.writeI32(self.device_index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.random_length is None:
            raise TProtocolException(message='Required field random_length is unset!')
        if self.random_num is None:
            raise TProtocolException(message='Required field random_num is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetRandomResp(object):
    """
    Attributes:
     - base
     - randoms

    """


    def __init__(self, base=None, randoms=None,):
        self.base = base
        self.randoms = randoms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = qutrunk.thrift.code.ttypes.BaseCode()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.randoms = []
                    (_etype152, _size149) = iprot.readListBegin()
                    for _i153 in range(_size149):
                        _elem154 = iprot.readBinary()
                        self.randoms.append(_elem154)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetRandomResp')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        if self.randoms is not None:
            oprot.writeFieldBegin('randoms', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.randoms))
            for iter155 in self.randoms:
                oprot.writeBinary(iter155)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        if self.randoms is None:
            raise TProtocolException(message='Required field randoms is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Amplitude)
Amplitude.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'reals', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'imags', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.I32, 'startind', None, None, ),  # 3
    (4, TType.I32, 'numamps', None, None, ),  # 4
)
all_structs.append(Matrix)
Matrix.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'reals', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 1
    (2, TType.LIST, 'imags', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 2
    (3, TType.BOOL, 'unitary', None, None, ),  # 3
)
all_structs.append(Cmdex)
Cmdex.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'amp', [Amplitude, None], None, ),  # 1
    (2, TType.STRUCT, 'mat', [Matrix, None], None, ),  # 2
)
all_structs.append(MeasureCond)
MeasureCond.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enable', None, None, ),  # 1
    (2, TType.I32, 'idx', None, None, ),  # 2
    (3, TType.I32, 'cond_value', None, None, ),  # 3
)
all_structs.append(Cmd)
Cmd.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'gate', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'targets', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'controls', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'rotation', (TType.DOUBLE, None, False), None, ),  # 4
    (5, TType.STRING, 'desc', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'inverse', None, None, ),  # 6
    (7, TType.STRUCT, 'cmdex', [Cmdex, None], None, ),  # 7
    (8, TType.STRUCT, 'cond', [MeasureCond, None], None, ),  # 8
)
all_structs.append(Circuit)
Circuit.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'cmds', (TType.STRUCT, [Cmd, None], False), None, ),  # 1
)
all_structs.append(MeasureQubit)
MeasureQubit.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'idx', None, None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)
all_structs.append(MeasureQubits)
MeasureQubits.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'measure', (TType.STRUCT, [MeasureQubit, None], False), None, ),  # 1
)
all_structs.append(MeasureResult)
MeasureResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'measures', (TType.STRUCT, [MeasureQubits, None], False), None, ),  # 1
)
all_structs.append(InitQubitsReq)
InitQubitsReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'qubits', None, None, ),  # 2
    (3, TType.BOOL, 'density', None, None, ),  # 3
    (4, TType.I32, 'exec_type', None, None, ),  # 4
    (5, TType.LIST, 'hosts', (TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(InitQubitsResp)
InitQubitsResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [qutrunk.thrift.code.ttypes.BaseCode, None], None, ),  # 1
)
all_structs.append(SendCircuitCmdReq)
SendCircuitCmdReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'circuit', [Circuit, None], None, ),  # 2
    (3, TType.BOOL, 'final', None, None, ),  # 3
)
all_structs.append(SendCircuitCmdResp)
SendCircuitCmdResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [qutrunk.thrift.code.ttypes.BaseCode, None], None, ),  # 1
)
all_structs.append(CancelCmdReq)
CancelCmdReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
)
all_structs.append(CancelCmdResp)
CancelCmdResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [qutrunk.thrift.code.ttypes.BaseCode, None], None, ),  # 1
)
all_structs.append(GetProbAmpReq)
GetProbAmpReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.I64, 'index', None, None, ),  # 2
)
all_structs.append(GetProbAmpResp)
GetProbAmpResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [qutrunk.thrift.code.ttypes.BaseCode, None], None, ),  # 1
    (2, TType.DOUBLE, 'amp', None, None, ),  # 2
)
all_structs.append(GetProbOfAllOutcomReq)
GetProbOfAllOutcomReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'targets', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetProbOfAllOutcomResp)
GetProbOfAllOutcomResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [qutrunk.thrift.code.ttypes.BaseCode, None], None, ),  # 1
    (2, TType.LIST, 'pro_outcomes', (TType.DOUBLE, None, False), None, ),  # 2
)
all_structs.append(GetAllStateReq)
GetAllStateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
)
all_structs.append(GetAllStateResp)
GetAllStateResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [qutrunk.thrift.code.ttypes.BaseCode, None], None, ),  # 1
    (2, TType.LIST, 'all_state', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(RunCircuitReq)
RunCircuitReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'shots', None, None, ),  # 2
)
all_structs.append(RunCircuitResp)
RunCircuitResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [qutrunk.thrift.code.ttypes.BaseCode, None], None, ),  # 1
    (2, TType.STRUCT, 'result', [MeasureResult, None], None, ),  # 2
)
all_structs.append(GetExpecPauliProdReq)
GetExpecPauliProdReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'pauli_prod', (TType.STRUCT, [PauliProdInfo, None], False), None, ),  # 2
)
all_structs.append(GetExpecPauliProdResp)
GetExpecPauliProdResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [qutrunk.thrift.code.ttypes.BaseCode, None], None, ),  # 1
    (2, TType.DOUBLE, 'expect', None, None, ),  # 2
)
all_structs.append(PauliProdInfo)
PauliProdInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'oper_type', None, None, ),  # 1
    (2, TType.I32, 'target', None, None, ),  # 2
)
all_structs.append(GetExpecPauliSumReq)
GetExpecPauliSumReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'oper_type_list', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'term_coeff_list', (TType.DOUBLE, None, False), None, ),  # 3
)
all_structs.append(GetExpecPauliSumResp)
GetExpecPauliSumResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [qutrunk.thrift.code.ttypes.BaseCode, None], None, ),  # 1
    (2, TType.DOUBLE, 'expect', None, None, ),  # 2
)
all_structs.append(GetRandomCardInfoReq)
GetRandomCardInfoReq.thrift_spec = (
)
all_structs.append(GetRandomCardInfoResp)
GetRandomCardInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [qutrunk.thrift.code.ttypes.BaseCode, None], None, ),  # 1
    (2, TType.I32, 'count', None, None, ),  # 2
    (3, TType.I32, 'driver_version', None, None, ),  # 3
    (4, TType.I32, 'library_version', None, None, ),  # 4
    (5, TType.LIST, 'cards', (TType.STRUCT, [RandomCardInfo, None], False), None, ),  # 5
)
all_structs.append(RandomCardInfo)
RandomCardInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'device_index', None, None, ),  # 1
    (2, TType.I32, 'mode', None, None, ),  # 2
    (3, TType.DOUBLE, 'ld_temp', None, None, ),  # 3
    (4, TType.DOUBLE, 'bd_temp', None, None, ),  # 4
    (5, TType.MAP, 'states', (TType.I32, None, TType.I32, None, False), None, ),  # 5
)
all_structs.append(SetRandomCardReq)
SetRandomCardReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'device_index', None, None, ),  # 1
    (2, TType.I32, 'mode', None, None, ),  # 2
    (3, TType.BOOL, 'reset', None, None, ),  # 3
)
all_structs.append(SetRandomCardResp)
SetRandomCardResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [qutrunk.thrift.code.ttypes.BaseCode, None], None, ),  # 1
)
all_structs.append(GetRandomReq)
GetRandomReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'random_length', None, None, ),  # 1
    (2, TType.I32, 'random_num', None, None, ),  # 2
    (3, TType.I32, 'device_index', None, None, ),  # 3
)
all_structs.append(GetRandomResp)
GetRandomResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [qutrunk.thrift.code.ttypes.BaseCode, None], None, ),  # 1
    (2, TType.LIST, 'randoms', (TType.STRING, 'BINARY', False), None, ),  # 2
)
fix_spec(all_structs)
del all_structs
